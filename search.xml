<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔2019]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9A%8F%E7%AC%942019%2F</url>
    <content type="text"><![CDATA[2019年 日常记录 2019-2-28 初步设置好了个人博客 关于 Latex 数学公式在 Hexo 中使用的参考 即使使用了上述方法，行内公式只有使用行间公式的符号才正常显示，有悖于习惯与通用的 MarkDown 编辑器。并且转义仍存在 bug 2019-3-7 更改 npm 全局安装目录 npm config set cache &quot;C:\Environment\JavaScript\NodePackages&quot; npm config set prefix &quot;C:\Environment\JavaScript\NodePackages&quot; 修改 .\node_modules\npm 路径中的 npmrc 文件 prefix=C:\Environment\JavaScript\NodePackages cache=C:\Environment\JavaScript\NodePackages Tensorflow2.0 将要更新，接口会出现较大变动，最近 tensorflow 的程序跑起来时常看到 warning 逐渐习惯了使用 vscode 2019-3-9 不知道为什么，突然想到了很久之前看过的小说。幸运的是，很快就找到了。 中国百科全书（四） 巴别乱 2019-3-18 MDN web docs]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐马尔可夫模型]]></title>
    <url>%2F2019%2F02%2F28%2FHMM%2F</url>
    <content type="text"><![CDATA[隐马尔可夫模型 (Hidden Markov Model) 是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其状态并不是直接可见的，但受状态影响的某些变量则是可见的，自然语言处理中被应用于中文分词。 缺点： 其做出的假设导致其不能考虑上下文的特征，限制了特征的选择 概念 马尔可夫模型：下一状态仅取决于当前状态，存在状态转移矩阵 隐马尔可夫模型：无法得知当前我想要的得知的状态（隐藏状态），但是可观察的状态与隐藏状态之间存在联系，根据可观察状态的序列找到一个最可能的隐藏状态序列 有限历史性假设 —— 下一状态仅取决于当前状态 齐次性假设 —— 状态转移概率与时刻无关 观察值独立性假设 —— 观察值仅取决于当前状态 五元组 观察序列（即文本）- O：小明硕士毕业于中国科学院计算所 状态序列 - S：BEBEBMEBEBMEBESB 代表该字是词语中的起始字​M 代表是词语中的中间字​E 代表是词语中的结束字​S 则代表是单字成词 初始状态概率向量－π：句子的第一个字属于{B,E,M,S}这四种状态的概率。 备注：示例数值是对概率值取对数之后的结果，为了将概率相乘的计算变成对数相加，其中-3.14e+100作为负无穷，也就是对应的概率值是 0​ 状态转移概率矩阵－A：已知前一个字的状态，后一个字状态为{B,E,M,S}的概率 观测概率矩阵－B：在在已知某一位置字的状态的条件下，观察值为特定字的概率 Viterbi 算法需要做的工作：找到的最大的 P(S_1, S_2, ... |\space O_1, O_2, ...)，并认为其对应的状态为每个文字实际的状态 P(S_1, S_2, ... |\space O_1, O_2, ...) = P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) / P(O_1, O_2, ...)因而只需要比较 P(O_1, O_2, ... |\space S_1, S_2, ...)* P(S_1, S_2, ...)齐次性假设: 状态转移矩阵不变观察值独立性假设: P(O_1, O_2, ... |\space S_1, S_2, ...) = P(O_1 |\space S_1, S_2, ...) * P(O_2 |\space S_1, S_2, ...) * ... = P(O_1 | S_1) * P(O_2 | S_2) * ...有限历史性假设: P(S_1, S_2, ...) = P(S_1) * P(S_2 | S_1) * P(S_3 | S_1, S_2) * ... = P(S_1) * P(S_2 | S_1) * P(S_3 | S_2) * ...P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) = [P(O_1 | S_1) * P(S_1)] * [P(O_2 | S_2) * P(S_2 | S_1)] * [P(O_3 | S_3) * P(S_3 | S_2)] * ... 定义二维数组 weight[4][15]，4为状态的数量，15为输入句子的字数。 使用初始状态概率向量初始化 weight[i][0] 初始状态概率向量－π 已知 由观测概率矩阵得到 初始化 weight[i][0]，注: weight[i][0] = P(O1 | S1) * P(S1) 遍历句子计算 weight 二维数组weight[i][j] = max{ weight [t][j - 1] + transPos[t][i] + emitProb[i][sentence[j]], 其中 0&lt;= t &lt;= 3}transPos 为状态转移矩阵，emitPos 为观察概率矩阵 确定边界条件以及路径回溯 边界条件：句中最后一个字状态只可能为 E 或者 S 路径回溯：计算开始时可以新建一个与 weight 维数相同的矩阵，储存上一个字的状态，方便回溯 主要参考: 中文分词之HMM模型详解]]></content>
      <categories>
        <category>NLP</category>
        <category>中文分词</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello NexT]]></title>
    <url>%2F2019%2F02%2F27%2FHelloNexT%2F</url>
    <content type="text"><![CDATA[Theme NexT 安装当前目录为博客所在目录1git clone https://github.com/iissnan/hexo-theme-next themes/next NexTElegant Theme for Hexo]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
</search>
