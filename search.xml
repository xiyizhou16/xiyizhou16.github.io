<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔2022]]></title>
    <url>%2F2022%2F03%2F12%2F%E9%9A%8F%E7%AC%942022%2F</url>
    <content type="text"><![CDATA[2022年 日常记录 2022-3-12 Tango To Evora The Farewell Deadman’s Gun Just Give Me a Reason 湾 Harmonious Try 2022-4-20 Ortec的官网也太花哨了:)，第一次见到动画如此繁杂的官网。]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KernelRidgeRegression]]></title>
    <url>%2F2021%2F04%2F04%2FKernelRidgeRegression%2F</url>
    <content type="text"><![CDATA[核岭回归推导 问题描述给定训练集 ${(\mathbf{x}_i, y_i)}^{N}_{i=1}$，其中 $\mathbf{x}_{i} \in \mathbf{R}^d$ 而 $y_i \in \mathbf{R}$。令 $\phi$ 为 $\mathbf{R}^d \to \mathbf{R}^{m}$ 的 feature map，则核岭回归问题可如下表示: \min_{\mathbf{w}\in\mathbb{R}^m}\frac{\lambda}{2}||\mathbf{w}||^2 + \sum^N_{i=1}\big(\mathbf{w}^\mathsf{T}\phi(\mathbf{x}_i) - y_i\big)^2该问题需要推导预测函数 $f(\mathbf{x}) = \hat{\mathbf{w}}^{\mathsf{T}}\phi(\mathbf{x})$，且利用核函数 $k(\mathbf{x}, \mathbf{y})=\phi(\mathbf{x})^{\mathsf{T}}\phi(\mathbf{y})$ 使得 $f(\mathbf{x})$ 不包含 $\phi$ 注: 向量默认为列向量 $f(\mathbf{x})$ 推导过程对 $\mathbf{w}$ 求偏导使其等于 0 \lambda\mathbf{w} + 2\sum^N_{i=1}\big(\mathbf{w}^{\mathsf{T}}\phi(\mathbf{x}_i)-y_i\big)\phi(\mathbf{x}_i) = 0\hat{\mathbf{w}} = \Big(\lambda I_m + 2\sum^N_{i=1}\phi(\mathbf{x}_i)\phi(\mathbf{x}_i)^{\mathsf{T}}\Big) ^ {-1}\Big(2\sum^N_{j=1} y_i \phi(\mathbf{x}_j)\Big)令 $\Phi$ 为 $m\times N$ 矩阵，$\mathbf{y}$ 为 $N$ 维向量 \Phi = \big[\phi(\mathbf{x}_1), \phi(\mathbf{x}_2), \dots, \phi(\mathbf{x}_N)\big]\mathbf{y} = \big[y_1, y_2, \dots, y_N\big]^{\mathsf{T}}因而有 \sum^N_{i=1}\phi(\mathbf{x}_i)\phi(\mathbf{x}_i)^{\mathsf{T}} = \Phi\Phi^{\mathsf{T}}\sum^N_{j=1} y_i \phi(\mathbf{x}_j) = \Phi \mathbf{y}故 $\hat{\mathbf{w}}$ 可表示为 \hat{\mathbf{w}} = 2\big(\lambda I_m + 2\Phi\Phi^{\mathsf{T}} \big) ^ {-1} \Phi \mathbf{y}由 Matrix inversion lemmas，该公式的推导可参考 Matrix inversion lemmas - GitHub Pages (A−BD^{−1}C)^{−1}BD^{−1} = A^{−1}B(D−CA^{−1}B)^{−1}令 $A = I_m,\; B = 2\Phi,\; C = -\Phi^{\mathsf{T}},\; D^{-1} = \lambda^{-1}I_N$ 因而 \big(I_m + 2\lambda^{-1}\Phi\Phi^{\mathsf{T}}\big)^{-1}2\lambda\Phi = 2\Phi \big(\lambda I_N + 2\Phi^{\mathsf{T}}\Phi\big)^{-1}\hat{\mathbf{w}} = 2\Phi \big(\lambda I_N + 2\Phi^{\mathsf{T}}\Phi\big)^{-1} \mathbf{y}对于预测 \begin{split} f(\mathbf{x}) &= \hat{\mathbf{w}}^{\mathsf{T}} \phi(\mathbf{x}) \\ &= 2\mathbf{y}^{\mathsf{T}} \big(\lambda I_N + 2\Phi^{\mathsf{T}}\Phi\big)^{-1} \Phi^{\mathsf{T}} \phi(\mathbf{x}) \\ &= 2\mathbf{y}^{\mathsf{T}} \big(\lambda I_N + 2K \big)^{-1} \kappa(\mathbf{x}) \end{split}其中 $K$ 为 $N\times N$ 矩阵 K_{ij} = \phi(\mathbf{x}_i)^{\mathsf{T}}\phi(\mathbf{x}_j) = k(\mathbf{x}_i, \mathbf{x}_j)\kappa(\mathbf{x}) = \big[\phi(\mathbf{x}_1)^{\mathsf{T}}\phi(\mathbf{x}), \dots, \phi(\mathbf{x}_N)^{\mathsf{T}}\phi(\mathbf{x}) \big]^{\mathsf{T}} = \big[k(\mathbf{x}_1, \mathbf{x}), \dots, k(\mathbf{x}_N, \mathbf{x})\big]^{\mathsf{T}}Python 代码以下代码仅适用于 $x\in\mathbb{R}$ 的情形1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import mathimport numpy as npimport matplotlib.pyplot as pltdef target_function(x): return -5 + 20 * x - 16 * x ** 2def gene_dataset(): dataset_size = 30 np.random.seed(2021) data_x = np.random.uniform(0, 1, dataset_size) data_epsilon = np.random.normal(0, 1, dataset_size) data_y = target_function(data_x) + data_epsilon * 2 / 5 return data_x, data_yclass KernelRidge: def __init__(self, x, y, lam, kernel_function): self.x, self.kernel_function = x, kernel_function y_t = np.mat(y) dataset_size = len(x) lam_i = lam * np.mat(np.identity(dataset_size)) k = np.mat(np.zeros((dataset_size, dataset_size))) for i in range(0, dataset_size): for j in range(0, dataset_size): k[i, j] = kernel_function(x[i], x[j]) self.coefficient_vec = 2 * y_t * np.linalg.inv(lam_i + 2 * k) def predict(self, x): prediction_y = np.zeros(len(x)) for i in range(0, len(x)): kappa = np.mat(np.zeros(len(self.x))).T for j in range(0, len(self.x)): kappa[j, 0] = self.kernel_function(self.x[j], x[i]) prediction_y[i] = self.coefficient_vec * kappa return prediction_ydef kernel0(x, y): return 1 + x * ydef kernel1(x, y): return (1 + x * y) ** 2def kernel2(x, y): return (1 + x * y) ** 9def kernel3(x, y): return min(x, y)def kernel4(x, y): return math.exp(-(x - y) ** 2)def main(): x, y = gene_dataset() kernel_ridge = KernelRidge(x, y, 0.01, kernel0) x_prediction = np.linspace(0, 1, 100) y_prediction = kernel_ridge.predict(x_prediction) plt.scatter(x, y) plt.plot(x_prediction, y_prediction, 'g') plt.plot(x_prediction, target_function(x_prediction), 'r') plt.show()if __name__ == '__main__': main() 下图为不同核函数与 $\lambda$ 取值时预测结果，红线为目标函数，蓝色散点为目标函数加入高斯噪声后生成的数据集，绿线为岭回归拟合曲线。]]></content>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2021]]></title>
    <url>%2F2021%2F03%2F17%2F%E9%9A%8F%E7%AC%942021%2F</url>
    <content type="text"><![CDATA[2021年 日常记录 2021-3-17 图像重建相关期刊 Medical Image Analysis IEEE Transactions on Medical Imaging European Journal of Nuclear Medicine and Molecular Imaging 2021-4-9 玄学调参 :) 2021-8-29 小波变换与图像、图形处理技术 淤泥之花与空心石 Drunken Whaler 2021-9-10 An Angel 这世界那么多人 The Rains of Castamere 送你一朵小红花 2021-9-25 如愿 2021-9-29 Blind Tom 2021-10-30 漠河舞厅 2021-11-16 野火一季 2021-11-17 英雄联盟双城之战 2021-11-23 今天折腾梯子的时候把电脑的无线网弄出问题了，但火绒的断网修复一下就解决了。 2021-11-24 Clash 用做代理软件还不错，比 v2rayN 方便不少。 2021-11-26 The Show sign 0 (サインノート) 约定 Enemy 2021-11-28 For fruit basket 2021-12-10 达成成就 —— 使用 PhotoShop 绘制三视图。不过太痛苦了，以后再也不会尝试了。 江南的短篇小说《刹那公子》略微有趣。 前些天看论文时看到了一个有趣的批判。依据简化模型来解决逆问题，但仿真产生的数据却使用了该简化模型，在此验证中只会得到算法的理想效果。 the procedure of first simplifying the model, developing an estimator based on this model and then testing it against data produced with the same simplified mode Imagine Dragons 的歌感觉不错，最近找歌愈发艰难 Whatever It Takes Warriors Natural Believer 2021-12-14 Wing$ 白兰鸽巡游记 阴天 皆非 2021-12-17 AN INTRODUCTION TO OPTIMIZATION, FOURTH EDITION 泛函分析基础 2021-12-24 Sleepyhead]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Tom, Dick, and Mary Discover the DFT 阅读笔记]]></title>
    <url>%2F2020%2F11%2F04%2FTomDickMaryDiscoverDFT%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Tom, Dick, and Mary Discover the DFT 这篇文章对数字信号处理中离散傅里叶变换 (DFT) 进行了介绍，展示了其与傅里叶变换 (FT) 的联系。本文为该文章的阅读笔记 目的计算连续时间信号的傅里叶变换，绘制其幅频曲线和相频曲线。因工作量过大希望通过电脑进行计算，这要求输入时间信号为离散值，且能够获得频域的采样值。 时域周期延拓实现频域离散对于连续时间信号 $x_1(t)$，其傅里叶变换 (FT) 得到的频谱为 X_1(f) = \int^{\infty}_{-\infty}x_1(t)e^{-j2\pi ft}dt \tag{1}为了得到 $X_1(f)$ 的离散采样，将非周期信号 $x_1(t)$ 进行周期延拓，并计划对其应用傅里叶级数以获得离散的频谱采样。于是定义周期信号 $y(t)$: y(t) = \sum^{\infty}_{k=-\infty}x_1(t-kT_y) \tag{2}因而计算得到 $y(t)$ 的傅里叶级数 (FS) 为: y(t) = \sum^{\infty}_{m=-\infty}\alpha_me^{j2\pi mf_y t}, \qquad f_y = \frac{1}{T_y} \tag{3}傅里叶系数 $\alpha_m$ 可表示为: \alpha_m = \frac{1}{T_y} \int^{T_y/2}_{-T_y/2} y(t)e^{-j2\pi m f_y t}dt \tag{4}因为式$(4)$的计算仅使用了 $y(t)$ 的一个周期，故能够通过 $x_1(t)$ 替代 $y(t)$ \begin{split} \alpha_m &= \frac{1}{T_y} \int^{T_y/2}_{-T_y/2} x_1(t)e^{-j2\pi m f_y t}dt\\ &= \frac{1}{T_y} \int^{\infty}_{-\infty} x_1(t)e^{-j2\pi m f_y t}dt\\ &= \frac{1}{T_y} X_1(mf_y) \end{split} \tag{5}其中 $T_1$ 为 $x_1(t)$ 的时域宽度，仅 $T_1 \le T_y$ 时，式$(5)$的推导过程是成立的。当 $T_1 &gt; T_y$ 时，$x_1(t)$ 的周期延拓出现不同周期之间的交叠，此时 $x_1(t)$ 与 $y(t)$ 的单个周期在时域不相同。 不过从频域采样的角度来考虑，当频率采样间隔 $f_y&gt;1/T_1$ (即 $T_y &lt; T_1$) 时，时域信号周期延拓发生混叠，但其对应的离散频域序列仍然为 $X(f)$ 的采样。故 $T_1 &gt; T_y$ 时，仍然存在 $\alpha_m=X_1(mf_y)/T_y$。 因为并不确定式$(3)$的傅里叶级数表示等于式$(2)$的 $y(t)$，故将式$(3)$的傅里叶级数以 $y’(t)$ 表示。 y'(t) = \sum^{\infty}_{m=-\infty} \frac{1}{T_y} X_1(mf_y) e^{j2\pi mf_y t} \tag{6}通过冲激信号构建周期信号 $y’(t)$ 的傅里叶变换 \begin{split} Y'(f) &= \mathscr{F}[y'(t)]\\ &= \frac{1}{T_y} \int^{\infty}_{-\infty} \sum^{\infty}_{m=-\infty} X_1(mf_y) e^{j2\pi mf_y t} e^{-j2\pi f t}dt\\ &= \frac{1}{T_y}\sum^{\infty}_{m=-\infty} X_1(mf_y) \mathscr{F}[e^{j2\pi mf_y t}]\\ &= \frac{1}{T_y}\sum^{\infty}_{m=-\infty} X_1(mf_y) \delta(f-m f_y)\\ &= \frac{1}{T_y}X_1(f)\sum^{\infty}_{m=-\infty}\delta(f-m f_y) \end{split} \tag{7}对于单位冲激序列，其傅里叶变换 \mathscr{F}\Big[\sum^{\infty}_{m=-\infty}\delta(t-mT_y)\Big] = \frac{1}{T_y}\sum^{\infty}_{m=-\infty}\delta(f-mf_y) \tag{8}因而计算$Y’(f)$的傅里叶逆变换 \begin{split} y'(t) &= \mathscr{F}^{-1}\big[Y'(f)\big]\\ &= x_1(t) \ast \sum^{\infty}_{m=-\infty}\delta(t-mT_y)\\ &= \sum^{\infty}_{k=-\infty}x_1(t-kT_y) = y(t) \end{split} \tag{9}由此可以确定在 $T_1 \le T_y$ 时，式$(6)$傅里叶级数所表示的 $y’(t)$ 就是 $x(t)$ 的周期延拓 $y(t)$。 因而周期延拓的周期 $T_y$ 不小于非周期连续时间信号 $x(t)$ 的时域宽度时，可通过周期延拓构建周期连续时间信号 $y(t)$。计算 $y(t)$ 的傅里叶级数后，可通过式$(5)$得到 $X_1(f)$ 的采样值。 频域周期延拓实现时域离散若 $x(t)$ 是时限的，那么其傅里叶变换得到的 $X(f)$ 必不是有限带宽的，反之亦然。上文所使用的 $x_1(t)$ 为有限长，则为无限带宽，不过为便于之后的推导，先假设 $x_1(t)$ 的傅里叶变换在频域带宽有限。 当 $x_1(t)$ 为实函数时，若 $X_1(f)=\mathscr{F}[x_1(t)]$，则有 $F(-f)=F^{\ast}(f)$。故假设 $X_1(f)$ 单边频域带宽为 $f_b$，对 $X_1(f)$ 在频域上进行周期延拓，周期为 $f_s$，且 $f_s \ge 2f_b$。 Y(f) = \sum^{\infty}_{n=-\infty}X_1(f-nf_s) \tag{10}类似于式$(3)$，写出 $Y(f)$ 的傅里叶级数表示 Y(f) = \sum^{\infty}_{n=-\infty}\beta_n e^{j2\pi nT_s f}, \qquad T_s = \frac{1}{f_s} \tag{11}类似于式$(4)$和式$(5)$，计算系数 $\beta_n$ \begin{split} \beta_n &= \frac{1}{f_s} \int^{f_s/2}_{-f_s/2} Y(f)e^{-j2\pi n T_s f}df\\ &= \frac{1}{f_s} \int^{\infty}_{-\infty} X_1(f) e^{-j2\pi n T_s f}df\\ &= \frac{1}{f_s} x_1(-n T_s) \end{split} \tag{12}结合式$(11)$和式$(12)$ \begin{split} Y(f) &= \sum^{\infty}_{n=-\infty} \frac{1}{f_s} x_1(-n T_s) e^{j2\pi nT_s f}\\ &= \frac{1}{f_s} \sum^{\infty}_{n=-\infty} x_1(n T_s) e^{-j2\pi nT_s f} \end{split}\tag{13}因而在 $f_s=1/T_s\ge2f_b$ 的情况下，可以通过 $x_1(t)$ 的采样值计算 $Y(f)$，而 $Y(f)$ 的一个周期与 $X_1(f)$ 相同。 故任意选取 $f_0$ 使得 $-f_b\le f_0 \le f_b$，则有: Y(f_0)=X_1(f_0)=\frac{1}{f_s} \sum^{\infty}_{n=-\infty} x_1(n T_s) e^{-j2\pi nT_s f_0} \tag{14}仅需要输入 $x_1(t)$ 的离散抽样值，故可以根据式$(14)$ 通过计算机计算得到 $X_1(f)$ 的采样值。 目前存在的问题是 $X_1(f)$ 待求，不知道其频域带宽 $2f_b$，故暂时只能对 $f_s$ 的值进行猜测，例如任取 $f_s=1Hz$ 完成对 $x_1(t)$ 的抽样。 Gold Stars: Part One第3节的内容体现了香农采样定理: 对连续时间信号 $x_1(t)$ 以足够高的速率($f_s=1/T_s\ge2f_b$)进行采样时，那么该时间信号能够通过其时域采样 $x_1(nT_s)$ 重建出来。 在采样频率并不是足够高($f_s&lt;2f_b$)或者 $X_1(f)$ 频域带宽无限时，$Y(f)$ 单个周期也会接近于 $X_1(f)$，因为 $Y(f)$ 是 $X_1(f)$ 发生了频域混叠的周期延拓。采样频率设置为 $f_s$，若真实的 $X_1(f)$ 的能量主要集中在 $-f_s\le f \le f_s$，则式14计算得到 $X_1(f)$ 与真实频谱也只会有少许差异。 第3节中式$(13)$接近于离散时间序列的傅里叶变换(DTFT)， DTFT可表示为 Y_{DTFT}(f) = \sum^{\infty}_{n=-\infty} x(nT_s)e^{-j2\pi f n T_s} \tag{15}相较之下，式$(13)$多了系数 $T_s = 1/f_s$。 对于使用计算机进行谱分析，如果有一个变换能够建立频域采样和时域采样之间的联系，那这个变换将会十分实用。所以 Onward to the DFT Onward to the DFTx_3(t) = (0.9)^{-1000t}[u(t)-u(t-0.0151)] \tag{16}其中 $u(t)$ 为单位阶跃信号，因为 $x_3(t)$ 时域宽度有限，故其频域带宽无限。 此时以 $T_s=1ms$ 获得了N个时域的采样 $x_3(0), x_3(T_s)\dots x_3\big((N-1)T_s\big)$，并希望通过这一系列时域采样获得 $X_3(f)$ 的频域采样值。 现在根据这一系列时域采样值虽然无法得到 $X_3(f)$，但是可以类似于式(13)计算出 $X_3(f)$ 发生混叠的周期延拓 $Y(f)$，显然 $Y(f)$ 周期为 $f_s$。 Y(f) = \frac{1}{f_s} \sum^{N-1}_{n=0}x_3(nT_s)e^{-j2\pi nT_s f} \tag{17}构造 $Y_3(f)$ Y_3(f) = \left\{ \begin{array}{ll} Y(f),\qquad -f_s/2 \le f \le f_s/2\\ 0,\qquad otherwise \end{array} \tag{18} \right.令 $y_3(t)$ 为 $Y_3(f)$ 对应的时域信号，显然 $y_3(t)$ 在时域无限长。不过仍然构建 $y_3(t)$ 发生混叠的时域周期延拓。 w(t) = \sum^{\infty}_{i=-\infty}y_3(t-iT_w) \tag{19}其中 $T_w$ 应为 $T_s$ 的整数倍，即 T_w = MT_s \quad or \quad f_w = \frac{1}{MT_s} \tag{20}因而可以写出 $w(t)$ 的傅里叶级数(FS) w(t) = \sum^{\infty}_{k=-\infty} \gamma_k e^{j2\pi k f_w t}, \qquad f_w = \frac{1}{T_w} \tag{21}其中 \gamma_k = \frac{1}{T_w} \int^{T_w/2}_{-T_w/2} w(t)e^{-j2\pi k f_w t} dt \tag{22}从第2节的推导可以知道，无论 $y_3(t)$ 的周期延拓 $w(t)$ 是否出现混叠 \gamma_k = \frac{1}{T_w} Y_3(k f_w) \tag{23}因而 w(t) = \frac{1}{T_w} \sum^{\infty}_{k = -\infty} Y_3(k f_w) e^{j2\pi k f_w t} \tag{24}限制 $kf_w$ 的取值范围，可以用 $Y(f)$ 替代 $Y_3(f)$ w(t) = \frac{1}{T_w} \sum_{k} Y(k f_w) e^{j2\pi k f_w t} \tag{25}其中 $k$ 的取值范围被限制使得 $-f_s/2 \le kf_w \le f_s/2$ 因而可以通过式$(25)$获得 $w(t)$ 的离散采样，使时域采样间隔等于 $x_3(t)$ 的采样间隔 $T_s$ w(n T_s) = \frac{1}{T_w} \sum_{k} Y(k f_w) e^{j2\pi k f_w n T_s} \tag{26}式$(26)$能够实现对 $y_3(t)$ 时域周期延拓信号 $w(t)$ 的采样，接下来需要判断 $y_3(t)$ 与原时域采样 $x_3(n T_s)$ 的联系，根据傅里叶逆变换 \begin{split} y_3(t) &= \int^{\infty}_{-\infty} Y_3(f) e^{j2\pi t f} df\\ &= \int^{f_s/2}_{-f_s/2} Y(f) e^{j2\pi t f} df\\ &= \int^{f_s/2}_{-f_s/2} \frac{1}{f_s} \sum^{N-1}_{n=0}x_3(nT_s)e^{-j2\pi nT_s f} e^{j2\pi t f} df\\ &= \frac{1}{f_s} \sum^{N-1}_{n=0} x_3(nT_s) \int^{f_s/2}_{-f_s/2} e^{j2\pi (t-nT_s)f} df \end{split} \tag{27}若取 $t=kT_s$，且 $0\le k \le N-1$，则 \int^{f_s/2}_{-f_s/2} e^{j2\pi (t-nT_s)f} df = \int^{f_s/2}_{-f_s/2} e^{j2\pi (k-n)T_s f} df = \left\{ \begin{array}{ll} f_s,\quad &n=k\\ 0,\quad &n \neq k \end{array} \right. \tag{28}对式$(27)$，取 $t=kT_s$ 且 $0\le k \le N-1$，进行化简 y_3(kT_s) = x_3(kT_s) \tag{29}将 $y_3(kT_s)$ 表示为 $y_3(nT_s),\quad 0\le n \le N-1$ y_3(nT_s) = x_3(nT_s) \tag{30}则有 \begin{split} w(nT_s) &= \sum^{\infty}_{i=-\infty}x_3(nT_s-iT_w)\\ &= \sum^{\infty}_{i=-\infty}x_3(nT_s-iM T_s) \end{split} \tag{31}由此可以得到 $w(nT_s)$ 的离散采样是 $x(nT_s)$ 离散采样的周期延拓。因为 $0 \le n \le N-1$，故只需要 $M \ge N$，就能使得 $x(nT_s)$的周期延拓不发生混叠。 令 $M=N$，根据 $T_w=MT_s$以及式$(26)$，则 \begin{split} x_3(nT_s) &= \frac{1}{NT_s} \sum_k Y\Big(\frac{k f_s}{N}\Big) e^{j2\pi k f_s n T_s / N}\\ &= \frac{1}{NT_s} \sum_k Y\Big(\frac{k f_s}{N}\Big) e^{j2\pi k n / N} \end{split} \tag{32}其中 $n = 0, 1, \dots , N - 1$，且有 $-f_s/2 \le kf_s/N \le f_s/2$。 因为 $Y(f)$ 是 $X_3(f)$ 的周期延拓，所以由式$(14)$ \begin{split} Y\Big(\frac{k f_s}{N}\Big) &= \frac{1}{f_s}\sum^{N-1}_{n=0} x_3(nT_s)e^{-j2\pi nT_s kf_s / N}\\ &= \frac{1}{f_s}\sum^{N-1}_{n=0} x_3(nT_s)e^{-j2\pi n k / N} \end{split} \tag{33}其中 $-f_s/2 \le kf_s/N \le f_s/2$。 Gold Stars: Part Two因为 $Y_{DTFT}(f)=f_s Y(f)$ Y_{DTFT}\Big(\frac{k f_s}{N}\Big) = \sum^{N-1}_{n=0} x_3(nT_s)e^{-j2\pi n k / N} \tag{34}则相应的逆变换为 x_3(nT_s) = \frac{1}{N} \sum_k Y_{DTFT}\Big(\frac{k f_s}{N}\Big) e^{j2\pi k n / N} \tag{35}其中 $n = 0, 1, \dots , N - 1$，且有 $-f_s/2 \le kf_s/N \le f_s/2$。 因为 $Y(f)$ 是 $X_3(f)$ 周期为 $f_s$ 的周期延拓，故 $Y_{DTFT}(k f_s / N)$ 周期为 $f_s$，因而有: Y_{DTFT}\Big(\frac{(k+N) f_s}{N}\Big) = Y_{DTFT}\Big(\frac{k f_s}{N}+f_s\Big) = Y_{DTFT}\Big(\frac{(k+N) f_s}{N}\Big) \tag{36}且因为: e^{j2\pi (k + N) n / N} = e^{j2\pi k n / N} e^{j2\pi} = e^{j2\pi k n / N} \tag{37}所以式$(35)$可以变换为: x_3(nT_s) = \frac{1}{N} \sum^{N-1}_{k=0} Y_{DTFT}\Big(\frac{k f_s}{N}\Big) e^{j2\pi k n / N} \tag{38}其中 $n = 0, 1, \dots , N - 1$ 式$(34)$和式$(38)$即为离散傅里叶变换(DFT)，DFT通常表示为: X_3(k) = \sum^{N-1}_{n=0}x_3(n)e^{-j2\pi nk/N}, \quad k=0,1,\dots,N-1和 x_3(n) = \frac{1}{N}\sum^{N-1}_{k=0}X_3(k)e^{j2\pi k n/N}, \quad n=0,1,\dots,N-1]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>DigitalSignal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辐射成像随记]]></title>
    <url>%2F2020%2F09%2F15%2F%E8%BE%90%E5%B0%84%E6%88%90%E5%83%8F%E5%8E%9F%E7%90%86%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[辐射成像 学习随记 成像 CT X-CT: X射线计算机断层成像（X-Ray Computed Tomography) PET 正电子发射计算机断层成像(Positron emission tomography) 将半衰期较短的放射性同位素注入人体内，放射性同位素衰变释放正电子，正电子湮灭产生一对光子 SPECT 单光子发射计算机断层成像(Single-photon emission computed tomography) 将半衰期较短的放射性同位素注入人体内，放射性同位素衰变释放光子 MRI 核磁共振成像(Nuclear Magnetic Resonance Imaging)]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深度学习随记]]></title>
    <url>%2F2020%2F09%2F08%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[深度学习 学习随记 基础概念损失函数 0-1 损失函数(0-1 Loss Function) 模型在训练集上的错误率 不连续且倒数L\big(y, f(\vec{x}; \theta)\big) = \left\{ \begin{array}{ll} 0 & \textrm{if $y = f(\vec{x}; \theta)$}\\ 1 & \textrm{if $y \ne f(\vec{x}; \theta)$}\\ \end{array} \right. 平方损失函数(Quadratic Loss Function) 通常不适用于分类问题L\big(y, f(\vec{x}; \theta)\big) = \frac{1}{2}\Big(y - f(\vec{x}; \theta)\Big)^2 交叉熵损失函数(Cross-Entropy Loss Function)L\big(y, f(\vec{x}; \theta)\big) = -y\:\mathrm{log}f(\vec{x}; \theta) 最大后验估计(Maximum A Posteriori Estimation, MAP) $x$ 为随机变量，其采样分布的条件概率函数为 $f(x | \theta)$ 假设参数 $\theta$ 存在先验分布，其概率密度函数为 $g(\theta)$，将 $\theta$ 视为贝叶斯统计中的一个随机变量，则f(\theta|x)=\frac{f(x|\theta)\:g(\theta)}{\int_\Theta f(x|\vartheta)\:g(\vartheta)d\vartheta} 计算 $\theta$ 的最大似然估计\theta_{MAP}(x)=\mathrm{arg}\:\mathrm{max}\:f(\theta|x)=\mathrm{arg}\:\mathrm{max}\:\frac{f(x|\theta)\:g(\theta)}{\int_\Theta f(x|\vartheta)\:g(\vartheta)d\vartheta}=\mathrm{arg}\:\mathrm{max}\:f(x|\theta)\:g(\theta) 矩阵乘积 Hadamard Product[\boldsymbol{A}\odot\boldsymbol{B}]_{mn}=a_{mn}b_{mn} Kronecker Product[\boldsymbol{A}\otimes\boldsymbol{B}]= \left[ \begin{array}{ccc} a_{11}\boldsymbol{B} & a_{12}\boldsymbol{B} & \ldots \\ a_{21}\boldsymbol{B} & a_{22}\boldsymbol{B} & \ldots \\ \vdots & \vdots & \ddots \end{array} \right] Outer Product $\vec{a}\in\mathbb{R}^M,\quad\vec{b}\in\mathbb{R}^N$\vec{a}\otimes\vec{b}= \left[ \begin{array}{ccc} a_{1}b_{1} & a_{1}b_{2} & \ldots \\ a_{2}b_{1} & a_{2}b_{2} & \ldots \\ \vdots & \vdots & \ddots \end{array} \right] 矩阵分解 奇异值分解 $\boldsymbol{A}$ 为实的 $m\times n$ 矩阵，且 $r(\boldsymbol{A})=r$，则存在 $m$ 阶正交矩阵 $\boldsymbol{U}$ 和 $n$ 阶正交矩阵 $\boldsymbol{V}$ 使得 $\boldsymbol{A}=\boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^{\mathrm{T}}$，其中 $\boldsymbol{\Sigma}=\left[ \begin{array}{ccc}\sigma_1 &amp; &amp; &amp;\\&amp; \sigma_2 &amp; &amp;\\&amp; &amp; \ddots &amp;\\&amp; &amp; &amp; \sigma_r\\&amp;\end{array} \right]$，满足 $\sigma_1\ge\sigma_2\ge\cdots\ge\sigma_r&gt;0$ $\boldsymbol{\Sigma}$ 的对角线元素为 $\boldsymbol{A}$ 的奇异值，$\boldsymbol{A}$ 的非零奇异值为 $\boldsymbol{AA}^{\mathrm{T}}$ 或者 $\boldsymbol{A}^{\mathrm{T}}\boldsymbol{A}$ 的非零特征值的平方根 相关函数 Softmax 函数 对向量进行归一化，凸显其中最大的值并抑制远低于最大值的其他分量 对于$K$个标量 $x_1, x_2, \cdots ,x_K$z_k = \mathrm{softmax}(x_k)=\frac{\mathrm{exp}(x_k)}{\sum^K_{i=1}\mathrm{exp}(x_i)} 理论Pytorch 参考资料:神经网络与深度学习线性代数与几何(下)维基百科]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2020]]></title>
    <url>%2F2020%2F09%2F06%2F%E9%9A%8F%E7%AC%942020%2F</url>
    <content type="text"><![CDATA[2020年 日常记录 2020-9-6 尝试将博客迁移至 Hugo，发现公式显示也存在问题 2020-9-8 整理了微信联系人 2020-9-13 降噪耳机，略有效果 2020-11-3 医学成像原理]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[立方体与线段交点计算]]></title>
    <url>%2F2020%2F09%2F05%2FCubeIntersectLine%2F</url>
    <content type="text"><![CDATA[Python 代码计算立方体与线段交点 前置说明 本代码中立方体各条边均平行于坐标轴 $\vec{x}$ 为线段上任意点，$\vec{x}_{start}$ 为线段起始点，$\vec{x}_{end}$ 为线段终点，则:\vec{x}=\vec{x}_{start}+t\cdot (\vec{x}_{end}-\vec{x}_{start}) $\vec{x}$ 为平面上任意点，$\vec{x}_0$ 为平面上一已知点，$\vec{n}$ 为平面法向量，则:(\vec{x}-\vec{x}_0)\cdot \vec{n} = 0 若平面与线段相交，线段系数 $t$ 的值为:t = \frac{(\vec{x}_0 - \vec{x}_{start}) \cdot \vec{n}}{(\vec{x}_{end}-\vec{x}_{start}) \cdot \vec{n}} 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081"""Author: xiyizhou16Date: 2020-09-04 21:50:18LastEditTime: 2020-09-05 12:14:19"""class Point: def __init__(self, point_x, point_y, point_z): self.coord = [point_x, point_y, point_z]# self.origin 为线段起始点坐标，坐标等同于 point_start# self.direction 可视为线段的方向向量class LineSegment: def __init__(self, point_start, point_end): origin = [] direction = [] for index in range(3): origin.append(point_start.coord[index]) direction.append(point_end.coord[index] - point_start.coord[index]) self.origin = origin self.direction = direction # 通过系数 t 获得其对应的线段上的点 # 0 &lt;= t &lt;= 1 意味着点在线段上 def get_point(self, coefficient): point_coord = [] for index in range(3): point_coord.append(self.origin[index] + coefficient * self.direction[index]) return Point(point_coord[0], point_coord[1], point_coord[2])# point_a, point_b 为平行于坐标轴的立方体处于对角位置的两个顶点class Box: def __init__(self, point_a, point_b): self.pA = point_a self.pB = point_b # 获得立方体与线段 line_segment 的两个交点 def get_intersect_point(self, line_segment): # 线段 direction 分量存在 0 预处理 for index, direction in enumerate(line_segment.direction): if direction == 0: box_max = max(self.pA.coord[index], self.pB.coord[index]) box_min = min(self.pA.coord[index], self.pB.coord[index]) if line_segment.origin[index] &gt; box_max or line_segment.origin[index] &lt; box_min: return None, None # 常规处理 t0, t1 = 0., 1. for index in range(3): if line_segment.direction[index] != 0.: inv_dir = 1. / line_segment.direction[index] t_near = (self.pA.coord[index] - line_segment.origin[index]) * inv_dir t_far = (self.pB.coord[index] - line_segment.origin[index]) * inv_dir if t_near &gt; t_far: t_near, t_far = t_far, t_near t0 = max(t_near, t0) t1 = min(t_far, t1) if t0 &gt; t1: return None, None intersection_point_near = line_segment.get_point(t0) intersection_point_far = line_segment.get_point(t1) return intersection_point_near, intersection_point_far # 获得立方体与线段的交线长度 def get_intersect_length(self, line_segment): near_point, far_point = self.get_intersect_point(line_segment) if near_point is None: return 0. length = 0. for index in range(3): length += (far_point.coord[index] - near_point.coord[index]) ** 2 return length ** 0.5if __name__ == '__main__': box = Box(Point(-1, -1, -1), Point(1, 1, 1)) line = LineSegment(Point(-2, -2, 0), Point(2, 2, 0)) print(box.get_intersect_length(line)) 代码解析 主要对 Box.get_intersect_point(self, line_segment) 进行说明 首先对线段 direction 为 0 的分量进行预处理(当线段平行于立方体平面时出现该情况) direction[i] == 0 意味着线段起点和终点的 i 轴坐标 coord[i] 相等，因而通过 LineSegment.origin[i] 与立方体两个对角顶点的 i 轴坐标作比较确定线段是否在立方体外，如果确认在外面则没有交点 常规处理先以二维情况作为说明，如图所示 求得二维矩形与线段的交点 如上图矩形存在两条边位于表达式为 x = const 的直线上，求出线段与这两条直线的交点。这两个交点的计算仅需要使用线段 direction 和 origin 对应于 x 轴的分量，可计算得到 $t0_x$ 和 $t1_x$，其中 $t0_x$ 相对较小(即距离线段起点更近) 类似可求得 $t0_y$ 和 $t1_y$。若计算的是二维矩形与直线的交点，则 $t_0$ 中的较大者对应点即为交点，而 $t_1$ 中的较小点为交点。存在限制条件，若 $t_0 &gt; t_1$ 则无交点 因为使用的是线段，实际上 $t_0$ 的取值应为 max(0, t0x, t0y)， $t_1$ 的取值应为 min(1, t1x, t1y) 可类推至三维空间中立方体与线段的相交 立方体存在两个面与表达式为 x = const 的平面重合，同样可计算得到 $t0_x$ 和 $t1_x$ 类似可求得 $t0_y$ 和 $t1_y$，$t0_z$ 和 $t1_z$。则 $t_0$ 的取值为 max(0, t0x, t0y, t0z)， $t_1$ 的取值为 min(1, t1x, t1y, t1z) 若 $t_0 &lt; t_1$，则 $t_0$ 和 $t_1$ 对应于两个交点。若 $t_0 = t_1$，则线段与立方体相交于一个点。若 $t_0 &gt; t_1$，则没有交点 特殊情况说明 线段与立方体交点只有一个，返回两个坐标相同的点 线段仅起点在立方体内，则返回交点其中一个为起点。仅终点在立方体内，则返回交点其中一个为终点。二者都在立方体内，则返回交点为起点和终点 部分参考 Ray-Box Intersection]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geant4 安装]]></title>
    <url>%2F2020%2F07%2F09%2FGeant4%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Win10 配置 Geant4 + OpenGL + Qt 前置说明 如果 Geant4 安装未使用 OpenGL 及 Qt 作为可视化工具，可直接参考 Geant4 官网的安装指南，但该指南缺乏使用 OpenGL 及 Qt 的具体安装步骤，因而本文对 Windows 系统下 Geant4 的可视化安装过程进行记录说明，希望能够提供便利。 需要下载安装的软件 CMake Visual Studio Qt Geant4 本文编辑于 2020-07-08，安装所使用的软件版本为 CMake 3.17.3 Visual Studio Community 2019 Qt 5.15 MSVC 2019 64bit Geant4 4.10.06 安装步骤CMake 安装 CMake 下载链接，安装过程无须赘述。 Visual Studio 安装 关于能否使用 MinGW 编译 Geant4 的问题，Geant4 的官方说明是在 CMake 下这个编译理应是可以的，但是官方并没有进行相关的支持和测试。 Visual Studio 下载链接，下载免费的 Community 版本即可，仅需要安装”使用 C++ 的桌面开发” Qt 安装 Qt 下载链接，Qt 下载需要注册并登录，下载开源免费的版本即可，该链接下载下来的 .exe 文件为在线安装，需要网速及耐心。如果下载 5.15 之前的版本，推荐在 download.qt.io 上下载 Qt 的离线安装版本。另外 Geant4 官方推荐下载安装 Qt5。 笔者下载安装的 Qt 版本为 5.15，该版本的 Qt 存在 MSVC 2019 64bit 的 prebuilt components，对应于 VS2019。而在 download.qt.io 所能下载的最新版本为 5.14.2，仅有 MSVC 2017 和 2015。 此外，看到有的说法是 Qt 的 prebuilt components 的版本低于 Visual Studio 的版本 Geant4 也可以成功运行，笔者并未对此进行尝试。 Geant4 安装 Geant4 下载地址，需要下载 Gean4 源代码的压缩文件，笔者个人推荐此时将所有 Data Files 下载下来。 新建一个 DataFiles 的文件夹，将下载下来的所有 Data Files 解压到该文件夹内。 将 Geant4 源文件的压缩包解压，并在同级目录(非必须)下创建 build 和 install 两个文件夹。 因为 CMake 需要设置的参数较多，先使用 CMake GUI 设置完成相应的参数，然后按照 Geant4 官方的安装指南对 Geant4 进行编译安装，打开 CMake 的图形用户界面，source code 的路径选择为 Geant4 源码的解压文件夹，build the binaries 的路径选择为新建的 build 文件夹。 单击左下角的 Configure 按钮，在弹出的窗口中选择电脑中所安装的 Visual Studio 版本，然后点击 Finish。在 CMake GUI 的输出窗口你会看到关于 datasets 的 warning，此时你的 CMake GUI 显示应该类似于下图。 对于上图的变量，需要做一下修改 CMAKE_INSTALL_PREFIX: 路径修改为 install 文件夹，该变量为 Geant4 的安装位置，不修改也可以。 GEANT4_INSTALL_DATADIR: 路径修改为 DataFiles 文件夹，指定 datasets 的路径。如果没有在官网下载 Data Files，则需要将GEANT4_INSTALL_DATA 勾选为 True，勾选后 Geant4 在安装过程中会自动下载 Data Files，对网络稳定性有一定要求。 GEANT4_USE_OPENGL_WIN32: 勾选为 True。 GEANT4_USE_QT: 勾选为 True。 点击 Add Entry，在弹出窗口选择 Type 为 Path，Name 命名为 CMAKE_PREFIX_PATH，Value 选择为 Qt 安装目录下的 lib/cmake。该设置是为了让 CMake 找到 Geant4 所需要的 Qt 的库 —— Qt5Core、Qt5Gui、Qt5Widgets、Qt5OpenGL、Qt5PrintSupport https://geant4-forum.web.cern.ch/t/geant4-10-6-and-qt/1472 设置完成完成后，参数应类似于下图。 单击 Configure 按钮，此时输出窗口中应当没有 error 或者 warning。 再单击一次 Configure 按钮，此时没有变量显示为红色，然后单击 Generate 按钮，待其完成后关闭 CMake GUI 窗口。打开 Developer Command Prompt for VS201X，该命令窗口应当能够在电脑的 开始 -&gt; Visual Studio 201X 中的文件夹找到。 cd 至 build 文件夹下，运行 cmake --build . --config Release 命令，完成后运行 cmake --build . --config Release --target install 完成 Geant4 安装。 添加 DataFiles 的环境变量，可参考 Geant4 官网的 Postinstall Setup。 验证是否安装成功，可参考官网的 How to Make an Executable Program 对示例进行编译运行。示例编译完成后直接运行 exe 文件需要能够找到需要的 dll 文件的路径，可将 geant4_10_06_install/bin 和 Qt/5.15.0/msvc2019_64/bin 相应的路径添加进环境变量。 最后附上 exampleB1 的 Qt 可视化界面]]></content>
      <categories>
        <category>Geant4</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Apache PDFBox & POI]]></title>
    <url>%2F2019%2F11%2F18%2FApache-PDFBox%26POI%2F</url>
    <content type="text"><![CDATA[.pdf 和 .docx 文件创建 创建 pdf 使用工具 Apache PDFBox IDEA 依赖 jar fontbox-2.0.17.jar pdfbox-2.0.17.jar pdfbox-tools-2.0.17.jar preflight-2.0.17.jar xmpbox-2.0.17.jar commons-logging-1.2.jar 可参考链接 https://www.tutorialspoint.com/pdfbox/pdfbox_environment.htm 代码(创建带有一个空白页的pdf) 12345678910111213141516171819202122232425262728import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.pdmodel.PDPage;import java.io.IOException;class pdfBox &#123; void createPDF(String savePath, String fileName) &#123; PDDocument pdfFile = new PDDocument(); String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".pdf")) &#123; fileName += ".pdf"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; // 加入空页面 PDPage blankPage = new PDPage(); pdfFile.addPage(blankPage); pdfFile.save(savePath + fileName); pdfFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建 docx 使用工具 Apache POI IDEA 依赖 jar poi-4.1.1.jar poi-ooxml-4.1.1.jar poi-ooxml-schemas-4.1.1.jar xmlbeans-3.1.0.jar commons-compress-1.19.jar commons-logging-1.2.jar 可参考链接 https://www.w3cschool.cn/apache_poi_word/apache_poi_word_overview.htmlhttps://houbb.github.io/2019/02/14/poi-word-02-quick-start 代码(创建空白的docx) 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import org.apache.poi.xwpf.usermodel.XWPFDocument;class docBox &#123; void createDoc(String savePath, String fileName) &#123; XWPFDocument document = new XWPFDocument(); FileOutputStream out; String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".docx")) &#123; fileName += ".docx"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; out = new FileOutputStream(new File(savePath + fileName)); document.write(out); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>FileConvert</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc2Docx]]></title>
    <url>%2F2019%2F07%2F26%2FDoc2Docx%2F</url>
    <content type="text"><![CDATA[.doc 文件批量转换为 .docx 打开一个 word 能够打开的文件，按快捷键 Alt + F11 打开 Microsoft Visual Basic for Applications 窗口 在应用窗口点击 插入 &gt; 模块 输入代码123456789101112131415161718192021Sub ConvertDocToDocx() Dim xDlg As FileDialog Dim xFolder As Variant Dim xFileName As String Application.ScreenUpdating = False Set xDlg = Application.FileDialog(msoFileDialogFolderPicker) If xDlg.Show &lt;&gt; -1 Then Exit Sub xFolder = xDlg.SelectedItems(1) + "\" xFileName = Dir(xFolder &amp; "*.doc", vbNormal) While xFileName &lt;&gt; "" Documents.Open FileName:=xFolder &amp; xFileName, _ ConfirmConversions:=False, ReadOnly:=False, AddToRecentFiles:=False, _ PasswordDocument:="", PasswordTemplate:="", Revert:=False, _ WritePasswordDocument:="", WritePasswordTemplate:="", Format:= _ wdOpenFormatAuto, XMLTransform:="" ActiveDocument.SaveAs xFolder &amp; Replace(xFileName, "doc", "docx"), wdFormatDocumentDefault ActiveDocument.Close xFileName = Dir() Wend Application.ScreenUpdating = TrueEnd Sub 来源：extendOffice]]></content>
      <tags>
        <tag>FileConvert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2019]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9A%8F%E7%AC%942019%2F</url>
    <content type="text"><![CDATA[2019年 日常记录 2019-2-28 初步设置好了个人博客 关于 Latex 数学公式在 Hexo 中使用的参考 即使使用了上述方法，行内公式只有使用行间公式的符号才正常显示，有悖于习惯与通用的 MarkDown 编辑器。并且转义仍存在 bug 2019-3-7 更改 npm 全局安装目录 npm config set cache &quot;C:\Environment\JavaScript\NodePackages&quot; npm config set prefix &quot;C:\Environment\JavaScript\NodePackages&quot; 修改 .\node_modules\npm 路径中的 npmrc 文件 prefix=C:\Environment\JavaScript\NodePackages cache=C:\Environment\JavaScript\NodePackages Tensorflow2.0 将要更新，接口会出现较大变动，最近 tensorflow 的程序跑起来时常看到 warning 逐渐习惯了使用 vscode 2019-3-9 不知道为什么，突然想到了很久之前看过的小说。幸运的是，很快就找到了。 中国百科全书（四） 巴别乱 2019-3-18 MDN web docs 2019-3-23 selenium chrome 无界面 123456from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')driver = webdriver.Chrome(options=chrome_options) tesserocr 安装 Python 输入，注意输出列表的第一个元组，例: (‘cp37’, ‘cp37m’, ‘win_amd64’) 12import pip._internalpip._internal.pep425tags.get_supported() tesserocr下载，从该网址下载与之前输出元组所对应的 .whl 文件 通过 pip 安装下载到本地的文件，例:pip3 install tesserocr-2.4.0-cp37-cp37m-win_amd64.whl，当前工作目录为文件所在的目录 2019-4-2 pyquery 长时间未维护，对于 CSS4 中的伪类选择器语法支持不足(当然，也可能是因为当前流行的仍然为 CSS3，毕竟对于 CSS4 的语法浏览器没有足够的动力去支持，只要 HTML 结构足够好的话，CSS3 对于伪类选择器的语法支持个人感觉已经足够)。例如:not(:has())就没有添加支持，使得选择不含有特定元素的所有元素变成一件很困难的事情(对一个结构比较糟糕的网站使用 HTML 解析时，这个功能可能很重要) 使用 BeautifulSoup 的选择器会是更好的选择，对于 CSS4 的语法支持较好 2019-4-4 python requests 编码问题 2019-6-1 JavaScript internal character encoding 2019-11-18 https://www.bilibili.com/video/av55210171?t=278 https://www.bilibili.com/video/av58023628?t=253 2019-11-19 CT 科学文库相关书目 计算机断层成像技术 : 原理、设计、伪像和进展CT图像重建算法工业CT技术与原理医学成像的物理原理]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐马尔可夫模型]]></title>
    <url>%2F2019%2F02%2F28%2FHMM%2F</url>
    <content type="text"><![CDATA[隐马尔可夫模型 (Hidden Markov Model) 是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其状态并不是直接可见的，但受状态影响的某些变量则是可见的，自然语言处理中被应用于中文分词。 缺点： 其做出的假设导致其不能考虑上下文的特征，限制了特征的选择 概念 马尔可夫模型：下一状态仅取决于当前状态，存在状态转移矩阵 隐马尔可夫模型：无法得知当前我想要的得知的状态（隐藏状态），但是可观察的状态与隐藏状态之间存在联系，根据可观察状态的序列找到一个最可能的隐藏状态序列 有限历史性假设 —— 下一状态仅取决于当前状态 齐次性假设 —— 状态转移概率与时刻无关 观察值独立性假设 —— 观察值仅取决于当前状态 五元组 观察序列（即文本）- O：小明硕士毕业于中国科学院计算所 状态序列 - S：BEBEBMEBEBMEBESB 代表该字是词语中的起始字​M 代表是词语中的中间字​E 代表是词语中的结束字​S 则代表是单字成词 初始状态概率向量－π：句子的第一个字属于{B,E,M,S}这四种状态的概率。 备注：示例数值是对概率值取对数之后的结果，为了将概率相乘的计算变成对数相加，其中-3.14e+100作为负无穷，也就是对应的概率值是 0​ 状态转移概率矩阵－A：已知前一个字的状态，后一个字状态为{B,E,M,S}的概率 观测概率矩阵－B：在在已知某一位置字的状态的条件下，观察值为特定字的概率 Viterbi 算法需要做的工作：找到的最大的 P(S_1, S_2, ... |\space O_1, O_2, ...)，并认为其对应的状态为每个文字实际的状态 P(S_1, S_2, ... |\space O_1, O_2, ...) = P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) / P(O_1, O_2, ...)因而只需要比较 P(O_1, O_2, ... |\space S_1, S_2, ...)* P(S_1, S_2, ...)齐次性假设: 状态转移矩阵不变观察值独立性假设: P(O_1, O_2, ... |\space S_1, S_2, ...) = P(O_1 |\space S_1, S_2, ...) * P(O_2 |\space S_1, S_2, ...) * ... = P(O_1 | S_1) * P(O_2 | S_2) * ...有限历史性假设: P(S_1, S_2, ...) = P(S_1) * P(S_2 | S_1) * P(S_3 | S_1, S_2) * ... = P(S_1) * P(S_2 | S_1) * P(S_3 | S_2) * ...P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) = [P(O_1 | S_1) * P(S_1)] * [P(O_2 | S_2) * P(S_2 | S_1)] * [P(O_3 | S_3) * P(S_3 | S_2)] * ... 定义二维数组 weight[4][15]，4为状态的数量，15为输入句子的字数。 使用初始状态概率向量初始化 weight[i][0] 初始状态概率向量－π 已知 由观测概率矩阵得到 初始化 weight[i][0]，注: weight[i][0] = P(O1 | S1) * P(S1) 遍历句子计算 weight 二维数组weight[i][j] = max{ weight [t][j - 1] + transPos[t][i] + emitProb[i][sentence[j]], 其中 0&lt;= t &lt;= 3}transPos 为状态转移矩阵，emitPos 为观察概率矩阵 确定边界条件以及路径回溯 边界条件：句中最后一个字状态只可能为 E 或者 S 路径回溯：计算开始时可以新建一个与 weight 维数相同的矩阵，储存上一个字的状态，方便回溯 主要参考: 中文分词之HMM模型详解]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello NexT]]></title>
    <url>%2F2019%2F02%2F27%2FHelloNexT%2F</url>
    <content type="text"><![CDATA[Theme NexT 安装当前目录为博客所在目录1git clone https://github.com/iissnan/hexo-theme-next themes/next 数学公式正常显示 替换默认渲染引擎 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 解决语义冲突，找到node_modules/kramed/lib/rules/inline.js，对 inline 变量作出修改 1234//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, NexTElegant Theme for Hexo]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
