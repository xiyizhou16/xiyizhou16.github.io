<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深度学习随记]]></title>
    <url>%2F2020%2F09%2F08%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[深度学习 学习随记]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>AI</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2020]]></title>
    <url>%2F2020%2F09%2F06%2F%E9%9A%8F%E7%AC%942020%2F</url>
    <content type="text"><![CDATA[2020年 日常记录 2020-9-6 尝试将博客迁移至 Hugo，发现公式显示也存在问题 2020-9-8 整理了微信联系人]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[立方体与线段交点计算]]></title>
    <url>%2F2020%2F09%2F05%2FCubeIntersectLine%2F</url>
    <content type="text"><![CDATA[Python 代码计算立方体与线段交点 前置说明 本代码中立方体各条边均平行于坐标轴 $\vec{x}$ 为线段上任意点，$\vec{x}_{start}$ 为线段起始点，$\vec{x}_{end}$ 为线段终点，则:\vec{x}=\vec{x}_{start}+t\cdot (\vec{x}_{end}-\vec{x}_{start}) $\vec{x}$ 为平面上任意点，$\vec{x}_0$ 为平面上一已知点，$\vec{n}$ 为平面法向量，则:(\vec{x}-\vec{x}_0)\cdot \vec{n} = 0 若平面与线段相交，线段系数 $t$ 的值为:t = \frac{(\vec{x}_0 - \vec{x}_{start}) \cdot \vec{n}}{(\vec{x}_{end}-\vec{x}_{start}) \cdot \vec{n}} 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081"""Author: xiyizhou16Date: 2020-09-04 21:50:18LastEditTime: 2020-09-05 12:14:19"""class Point: def __init__(self, point_x, point_y, point_z): self.coord = [point_x, point_y, point_z]# self.origin 为线段起始点坐标，坐标等同于 point_start# self.direction 可视为线段的方向向量class LineSegment: def __init__(self, point_start, point_end): origin = [] direction = [] for index in range(3): origin.append(point_start.coord[index]) direction.append(point_end.coord[index] - point_start.coord[index]) self.origin = origin self.direction = direction # 通过系数 t 获得其对应的线段上的点 # 0 &lt;= t &lt;= 1 意味着点在线段上 def get_point(self, coefficient): point_coord = [] for index in range(3): point_coord.append(self.origin[index] + coefficient * self.direction[index]) return Point(point_coord[0], point_coord[1], point_coord[2])# point_a, point_b 为平行于坐标轴的立方体处于对角位置的两个顶点class Box: def __init__(self, point_a, point_b): self.pA = point_a self.pB = point_b # 获得立方体与线段 line_segment 的两个交点 def get_intersect_point(self, line_segment): # 线段 direction 分量存在 0 预处理 for index, direction in enumerate(line_segment.direction): if direction == 0: box_max = max(self.pA.coord[index], self.pB.coord[index]) box_min = min(self.pA.coord[index], self.pB.coord[index]) if line_segment.origin[index] &gt; box_max or line_segment.origin[index] &lt; box_min: return None, None # 常规处理 t0, t1 = 0., 1. for index in range(3): if line_segment.direction[index] != 0.: inv_dir = 1. / line_segment.direction[index] t_near = (self.pA.coord[index] - line_segment.origin[index]) * inv_dir t_far = (self.pB.coord[index] - line_segment.origin[index]) * inv_dir if t_near &gt; t_far: t_near, t_far = t_far, t_near t0 = max(t_near, t0) t1 = min(t_far, t1) if t0 &gt; t1: return None, None intersection_point_near = line_segment.get_point(t0) intersection_point_far = line_segment.get_point(t1) return intersection_point_near, intersection_point_far # 获得立方体与线段的交线长度 def get_intersect_length(self, line_segment): near_point, far_point = self.get_intersect_point(line_segment) if near_point is None: return 0. length = 0. for index in range(3): length += (far_point.coord[index] - near_point.coord[index]) ** 2 return length ** 0.5if __name__ == '__main__': box = Box(Point(-1, -1, -1), Point(1, 1, 1)) line = LineSegment(Point(-2, -2, 0), Point(2, 2, 0)) print(box.get_intersect_length(line)) 代码解析 主要对 Box.get_intersect_point(self, line_segment) 进行说明 首先对线段 direction 为 0 的分量进行预处理(当线段平行于立方体平面时出现该情况) direction[i] == 0 意味着线段起点和终点的 i 轴坐标 coord[i] 相等，因而通过 LineSegment.origin[i] 与立方体两个对角顶点的 i 轴坐标作比较确定线段是否在立方体外，如果确认在外面则没有交点 常规处理先以二维情况作为说明，如图所示 求得二维矩形与线段的交点 如上图矩形存在两条边位于表达式为 x = const 的直线上，求出线段与这两条直线的交点。这两个交点的计算仅需要使用线段 direction 和 origin 对应于 x 轴的分量，可计算得到 $t0_x$ 和 $t1_x$，其中 $t0_x$ 相对较小(即距离线段起点更近) 类似可求得 $t0_y$ 和 $t1_y$。若计算的是二维矩形与直线的交点，则 $t_0$ 中的较大者对应点即为交点，而 $t_1$ 中的较小点为交点。存在限制条件，若 $t_0 &gt; t_1$ 则无交点 因为使用的是线段，实际上 $t_0$ 的取值应为 max(0, t0x, t0y)， $t_1$ 的取值应为 min(1, t1x, t1y) 可类推至三维空间中立方体与线段的相交 立方体存在两个面与表达式为 x = const 的平面重合，同样可计算得到 $t0_x$ 和 $t1_x$ 类似可求得 $t0_y$ 和 $t1_y$，$t0_z$ 和 $t1_z$。则 $t_0$ 的取值为 max(0, t0x, t0y, t0z)， $t_1$ 的取值为 min(1, t1x, t1y, t1z) 若 $t_0 &lt; t_1$，则 $t_0$ 和 $t_1$ 对应于两个交点。若 $t_0 = t_1$，则线段与立方体相交于一个点。若 $t_0 &gt; t_1$，则没有交点 特殊情况说明 线段与立方体交点只有一个，返回两个坐标相同的点 线段仅起点在立方体内，则返回交点其中一个为起点。仅终点在立方体内，则返回交点其中一个为终点。二者都在立方体内，则返回交点为起点和终点 部分参考 Ray-Box Intersection]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Geant4 安装]]></title>
    <url>%2F2020%2F07%2F09%2FGeant4%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Win10 配置 Geant4 + OpenGL + Qt 前置说明 如果 Geant4 安装未使用 OpenGL 及 Qt 作为可视化工具，可直接参考 Geant4 官网的安装指南，但该指南缺乏使用 OpenGL 及 Qt 的具体安装步骤，因而本文对 Windows 系统下 Geant4 的可视化安装过程进行记录说明，希望能够提供便利。 需要下载安装的软件 CMake Visual Studio Qt Geant4 本文编辑于 2020-07-08，安装所使用的软件版本为 CMake 3.17.3 Visual Studio Community 2019 Qt 5.15 MSVC 2019 64bit Geant4 4.10.06 安装步骤CMake 安装 CMake 下载链接，安装过程无须赘述。 Visual Studio 安装 关于能否使用 MinGW 编译 Geant4 的问题，Geant4 的官方说明是在 CMake 下这个编译理应是可以的，但是官方并没有进行相关的支持和测试。 Visual Studio 下载链接，下载免费的 Community 版本即可，仅需要安装”使用 C++ 的桌面开发” Qt 安装 Qt 下载链接，Qt 下载需要注册并登录，下载开源免费的版本即可，该链接下载下来的 .exe 文件为在线安装，需要网速及耐心。如果下载 5.15 之前的版本，推荐在 download.qt.io 上下载 Qt 的离线安装版本。另外 Geant4 官方推荐下载安装 Qt5。 笔者下载安装的 Qt 版本为 5.15，该版本的 Qt 存在 MSVC 2019 64bit 的 prebuilt components，对应于 VS2019。而在 download.qt.io 所能下载的最新版本为 5.14.2，仅有 MSVC 2017 和 2015。 此外，看到有的说法是 Qt 的 prebuilt components 的版本低于 Visual Studio 的版本 Geant4 也可以成功运行，笔者并未对此进行尝试。 Geant4 安装 Geant4 下载地址，需要下载 Gean4 源代码的压缩文件，笔者个人推荐此时将所有 Data Files 下载下来。 新建一个 DataFiles 的文件夹，将下载下来的所有 Data Files 解压到该文件夹内。 将 Geant4 源文件的压缩包解压，并在同级目录(非必须)下创建 build 和 install 两个文件夹。 因为 CMake 需要设置的参数较多，先使用 CMake GUI 设置完成相应的参数，然后按照 Geant4 官方的安装指南对 Geant4 进行编译安装，打开 CMake 的图形用户界面，source code 的路径选择为 Geant4 源码的解压文件夹，build the binaries 的路径选择为新建的 build 文件夹。 单击左下角的 Configure 按钮，在弹出的窗口中选择电脑中所安装的 Visual Studio 版本，然后点击 Finish。在 CMake GUI 的输出窗口你会看到关于 datasets 的 warning，此时你的 CMake GUI 显示应该类似于下图。 对于上图的变量，需要做一下修改 CMAKE_INSTALL_PREFIX: 路径修改为 install 文件夹，该变量为 Geant4 的安装位置，不修改也可以。 GEANT4_INSTALL_DATADIR: 路径修改为 DataFiles 文件夹，指定 datasets 的路径。如果没有在官网下载 Data Files，则需要将GEANT4_INSTALL_DATA 勾选为 True，勾选后 Geant4 在安装过程中会自动下载 Data Files，对网络稳定性有一定要求。 GEANT4_USE_OPENGL_WIN32: 勾选为 True。 GEANT4_USE_QT: 勾选为 True。 点击 Add Entry，在弹出窗口选择 Type 为 Path，Name 命名为 CMAKE_PREFIX_PATH，Value 选择为 Qt 安装目录下的 lib/cmake。该设置是为了让 CMake 找到 Geant4 所需要的 Qt 的库 —— Qt5Core、Qt5Gui、Qt5Widgets、Qt5OpenGL、Qt5PrintSupport https://geant4-forum.web.cern.ch/t/geant4-10-6-and-qt/1472 设置完成完成后，参数应类似于下图。 单击 Configure 按钮，此时输出窗口中应当没有 error 或者 warning。 再单击一次 Configure 按钮，此时没有变量显示为红色，然后关闭 CMake GUI 窗口。打开 Developer Command Prompt for VS201X，该命令窗口应当能够在电脑的 开始 -&gt; Visual Studio 201X 中的文件夹找到。 cd 至 build 文件夹下，运行 cmake --build . --config Release 命令，完成后运行 cmake --build . --config Release --target install 完成 Geant4 安装。 添加 DataFiles 的环境变量，可参考 Geant4 官网的 Postinstall Setup。 验证是否安装成功，可参考官网的 How to Make an Executable Program 对示例进行编译运行。示例编译完成后直接运行 exe 文件需要能够找到需要的 dll 文件的路径，可将 geant4_10_06_install/bin 和 Qt/5.15.0/msvc2019_64/bin 相应的路径添加进环境变量。 最后附上 exampleB1 的 Qt 可视化界面]]></content>
      <categories>
        <category>Geant4</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Apache PDFBox & POI]]></title>
    <url>%2F2019%2F11%2F18%2FApache-PDFBox%26POI%2F</url>
    <content type="text"><![CDATA[.pdf 和 .docx 文件创建 创建 pdf 使用工具 Apache PDFBox IDEA 依赖 jar fontbox-2.0.17.jar pdfbox-2.0.17.jar pdfbox-tools-2.0.17.jar preflight-2.0.17.jar xmpbox-2.0.17.jar commons-logging-1.2.jar 可参考链接 https://www.tutorialspoint.com/pdfbox/pdfbox_environment.htm 代码(创建带有一个空白页的pdf) 12345678910111213141516171819202122232425262728import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.pdmodel.PDPage;import java.io.IOException;class pdfBox &#123; void createPDF(String savePath, String fileName) &#123; PDDocument pdfFile = new PDDocument(); String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".pdf")) &#123; fileName += ".pdf"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; // 加入空页面 PDPage blankPage = new PDPage(); pdfFile.addPage(blankPage); pdfFile.save(savePath + fileName); pdfFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建 docx 使用工具 Apache POI IDEA 依赖 jar poi-4.1.1.jar poi-ooxml-4.1.1.jar poi-ooxml-schemas-4.1.1.jar xmlbeans-3.1.0.jar commons-compress-1.19.jar commons-logging-1.2.jar 可参考链接 https://www.w3cschool.cn/apache_poi_word/apache_poi_word_overview.htmlhttps://houbb.github.io/2019/02/14/poi-word-02-quick-start 代码(创建空白的docx) 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import org.apache.poi.xwpf.usermodel.XWPFDocument;class docBox &#123; void createDoc(String savePath, String fileName) &#123; XWPFDocument document = new XWPFDocument(); FileOutputStream out; String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".docx")) &#123; fileName += ".docx"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; out = new FileOutputStream(new File(savePath + fileName)); document.write(out); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>FileConvert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc2Docx]]></title>
    <url>%2F2019%2F07%2F26%2FDoc2Docx%2F</url>
    <content type="text"><![CDATA[.doc 文件批量转换为 .docx 打开一个 word 能够打开的文件，按快捷键 Alt + F11 打开 Microsoft Visual Basic for Applications 窗口 在应用窗口点击 插入 &gt; 模块 输入代码123456789101112131415161718192021Sub ConvertDocToDocx() Dim xDlg As FileDialog Dim xFolder As Variant Dim xFileName As String Application.ScreenUpdating = False Set xDlg = Application.FileDialog(msoFileDialogFolderPicker) If xDlg.Show &lt;&gt; -1 Then Exit Sub xFolder = xDlg.SelectedItems(1) + "\" xFileName = Dir(xFolder &amp; "*.doc", vbNormal) While xFileName &lt;&gt; "" Documents.Open FileName:=xFolder &amp; xFileName, _ ConfirmConversions:=False, ReadOnly:=False, AddToRecentFiles:=False, _ PasswordDocument:="", PasswordTemplate:="", Revert:=False, _ WritePasswordDocument:="", WritePasswordTemplate:="", Format:= _ wdOpenFormatAuto, XMLTransform:="" ActiveDocument.SaveAs xFolder &amp; Replace(xFileName, "doc", "docx"), wdFormatDocumentDefault ActiveDocument.Close xFileName = Dir() Wend Application.ScreenUpdating = TrueEnd Sub 来源：extendOffice]]></content>
      <tags>
        <tag>FileConvert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2019]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9A%8F%E7%AC%942019%2F</url>
    <content type="text"><![CDATA[2019年 日常记录 2019-2-28 初步设置好了个人博客 关于 Latex 数学公式在 Hexo 中使用的参考 即使使用了上述方法，行内公式只有使用行间公式的符号才正常显示，有悖于习惯与通用的 MarkDown 编辑器。并且转义仍存在 bug 2019-3-7 更改 npm 全局安装目录 npm config set cache &quot;C:\Environment\JavaScript\NodePackages&quot; npm config set prefix &quot;C:\Environment\JavaScript\NodePackages&quot; 修改 .\node_modules\npm 路径中的 npmrc 文件 prefix=C:\Environment\JavaScript\NodePackages cache=C:\Environment\JavaScript\NodePackages Tensorflow2.0 将要更新，接口会出现较大变动，最近 tensorflow 的程序跑起来时常看到 warning 逐渐习惯了使用 vscode 2019-3-9 不知道为什么，突然想到了很久之前看过的小说。幸运的是，很快就找到了。 中国百科全书（四） 巴别乱 2019-3-18 MDN web docs 2019-3-23 selenium chrome 无界面 123456from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')driver = webdriver.Chrome(options=chrome_options) tesserocr 安装 Python 输入，注意输出列表的第一个元组，例: (‘cp37’, ‘cp37m’, ‘win_amd64’) 12import pip._internalpip._internal.pep425tags.get_supported() tesserocr下载，从该网址下载与之前输出元组所对应的 .whl 文件 通过 pip 安装下载到本地的文件，例:pip3 install tesserocr-2.4.0-cp37-cp37m-win_amd64.whl，当前工作目录为文件所在的目录 2019-4-2 pyquery 长时间未维护，对于 CSS4 中的伪类选择器语法支持不足(当然，也可能是因为当前流行的仍然为 CSS3，毕竟对于 CSS4 的语法浏览器没有足够的动力去支持，只要 HTML 结构足够好的话，CSS3 对于伪类选择器的语法支持个人感觉已经足够)。例如:not(:has())就没有添加支持，使得选择不含有特定元素的所有元素变成一件很困难的事情(对一个结构比较糟糕的网站使用 HTML 解析时，这个功能可能很重要) 使用 BeautifulSoup 的选择器会是更好的选择，对于 CSS4 的语法支持较好 2019-4-4 python requests 编码问题 2019-6-1 JavaScript internal character encoding 2019-11-18 https://www.bilibili.com/video/av55210171?t=278 https://www.bilibili.com/video/av58023628?t=253 2019-11-19 CT 科学文库相关书目 计算机断层成像技术 : 原理、设计、伪像和进展CT图像重建算法工业CT技术与原理医学成像的物理原理]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐马尔可夫模型]]></title>
    <url>%2F2019%2F02%2F28%2FHMM%2F</url>
    <content type="text"><![CDATA[隐马尔可夫模型 (Hidden Markov Model) 是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其状态并不是直接可见的，但受状态影响的某些变量则是可见的，自然语言处理中被应用于中文分词。 缺点： 其做出的假设导致其不能考虑上下文的特征，限制了特征的选择 概念 马尔可夫模型：下一状态仅取决于当前状态，存在状态转移矩阵 隐马尔可夫模型：无法得知当前我想要的得知的状态（隐藏状态），但是可观察的状态与隐藏状态之间存在联系，根据可观察状态的序列找到一个最可能的隐藏状态序列 有限历史性假设 —— 下一状态仅取决于当前状态 齐次性假设 —— 状态转移概率与时刻无关 观察值独立性假设 —— 观察值仅取决于当前状态 五元组 观察序列（即文本）- O：小明硕士毕业于中国科学院计算所 状态序列 - S：BEBEBMEBEBMEBESB 代表该字是词语中的起始字​M 代表是词语中的中间字​E 代表是词语中的结束字​S 则代表是单字成词 初始状态概率向量－π：句子的第一个字属于{B,E,M,S}这四种状态的概率。 备注：示例数值是对概率值取对数之后的结果，为了将概率相乘的计算变成对数相加，其中-3.14e+100作为负无穷，也就是对应的概率值是 0​ 状态转移概率矩阵－A：已知前一个字的状态，后一个字状态为{B,E,M,S}的概率 观测概率矩阵－B：在在已知某一位置字的状态的条件下，观察值为特定字的概率 Viterbi 算法需要做的工作：找到的最大的 P(S_1, S_2, ... |\space O_1, O_2, ...)，并认为其对应的状态为每个文字实际的状态 P(S_1, S_2, ... |\space O_1, O_2, ...) = P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) / P(O_1, O_2, ...)因而只需要比较 P(O_1, O_2, ... |\space S_1, S_2, ...)* P(S_1, S_2, ...)齐次性假设: 状态转移矩阵不变观察值独立性假设: P(O_1, O_2, ... |\space S_1, S_2, ...) = P(O_1 |\space S_1, S_2, ...) * P(O_2 |\space S_1, S_2, ...) * ... = P(O_1 | S_1) * P(O_2 | S_2) * ...有限历史性假设: P(S_1, S_2, ...) = P(S_1) * P(S_2 | S_1) * P(S_3 | S_1, S_2) * ... = P(S_1) * P(S_2 | S_1) * P(S_3 | S_2) * ...P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) = [P(O_1 | S_1) * P(S_1)] * [P(O_2 | S_2) * P(S_2 | S_1)] * [P(O_3 | S_3) * P(S_3 | S_2)] * ... 定义二维数组 weight[4][15]，4为状态的数量，15为输入句子的字数。 使用初始状态概率向量初始化 weight[i][0] 初始状态概率向量－π 已知 由观测概率矩阵得到 初始化 weight[i][0]，注: weight[i][0] = P(O1 | S1) * P(S1) 遍历句子计算 weight 二维数组weight[i][j] = max{ weight [t][j - 1] + transPos[t][i] + emitProb[i][sentence[j]], 其中 0&lt;= t &lt;= 3}transPos 为状态转移矩阵，emitPos 为观察概率矩阵 确定边界条件以及路径回溯 边界条件：句中最后一个字状态只可能为 E 或者 S 路径回溯：计算开始时可以新建一个与 weight 维数相同的矩阵，储存上一个字的状态，方便回溯 主要参考: 中文分词之HMM模型详解]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello NexT]]></title>
    <url>%2F2019%2F02%2F27%2FHelloNexT%2F</url>
    <content type="text"><![CDATA[Theme NexT 安装当前目录为博客所在目录1git clone https://github.com/iissnan/hexo-theme-next themes/next 数学公式正常显示 替换默认渲染引擎 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 解决语义冲突，找到node_modules/kramed/lib/rules/inline.js，对 inline 变量作出修改 1234//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, NexTElegant Theme for Hexo]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
</search>
