<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Apache PDFBox & POI]]></title>
    <url>%2F2019%2F11%2F18%2FApache-PDFBox%26POI%2F</url>
    <content type="text"><![CDATA[.pdf 和 .docx 文件创建 创建 pdf 使用工具 Apache PDFBox IDEA 依赖 jar fontbox-2.0.17.jar pdfbox-2.0.17.jar pdfbox-tools-2.0.17.jar preflight-2.0.17.jar xmpbox-2.0.17.jar commons-logging-1.2.jar 可参考链接 https://www.tutorialspoint.com/pdfbox/pdfbox_environment.htm 代码(创建带有一个空白页的pdf) 12345678910111213141516171819202122232425262728import org.apache.pdfbox.pdmodel.PDDocument;import org.apache.pdfbox.pdmodel.PDPage;import java.io.IOException;class pdfBox &#123; void createPDF(String savePath, String fileName) &#123; PDDocument pdfFile = new PDDocument(); String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".pdf")) &#123; fileName += ".pdf"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; // 加入空页面 PDPage blankPage = new PDPage(); pdfFile.addPage(blankPage); pdfFile.save(savePath + fileName); pdfFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 创建 docx 使用工具 Apache POI IDEA 依赖 jar poi-4.1.1.jar poi-ooxml-4.1.1.jar poi-ooxml-schemas-4.1.1.jar xmlbeans-3.1.0.jar commons-compress-1.19.jar commons-logging-1.2.jar 可参考链接 https://www.w3cschool.cn/apache_poi_word/apache_poi_word_overview.htmlhttps://houbb.github.io/2019/02/14/poi-word-02-quick-start 代码(创建空白的docx) 1234567891011121314151617181920212223242526import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import org.apache.poi.xwpf.usermodel.XWPFDocument;class docBox &#123; void createDoc(String savePath, String fileName) &#123; XWPFDocument document = new XWPFDocument(); FileOutputStream out; String pathSeparator = System.getProperty("file.separator"); if (!fileName.endsWith(".docx")) &#123; fileName += ".docx"; &#125; if (!savePath.endsWith(pathSeparator)) &#123; savePath += pathSeparator; &#125; try &#123; out = new FileOutputStream(new File(savePath + fileName)); document.write(out); out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>FileConvert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doc2Docx]]></title>
    <url>%2F2019%2F07%2F26%2FDoc2Docx%2F</url>
    <content type="text"><![CDATA[.doc 文件批量转换为 .docx 打开一个 word 能够打开的文件，按快捷键 Alt + F11 打开 Microsoft Visual Basic for Applications 窗口 在应用窗口点击 插入 &gt; 模块 输入代码123456789101112131415161718192021Sub ConvertDocToDocx() Dim xDlg As FileDialog Dim xFolder As Variant Dim xFileName As String Application.ScreenUpdating = False Set xDlg = Application.FileDialog(msoFileDialogFolderPicker) If xDlg.Show &lt;&gt; -1 Then Exit Sub xFolder = xDlg.SelectedItems(1) + "\" xFileName = Dir(xFolder &amp; "*.doc", vbNormal) While xFileName &lt;&gt; "" Documents.Open FileName:=xFolder &amp; xFileName, _ ConfirmConversions:=False, ReadOnly:=False, AddToRecentFiles:=False, _ PasswordDocument:="", PasswordTemplate:="", Revert:=False, _ WritePasswordDocument:="", WritePasswordTemplate:="", Format:= _ wdOpenFormatAuto, XMLTransform:="" ActiveDocument.SaveAs xFolder &amp; Replace(xFileName, "doc", "docx"), wdFormatDocumentDefault ActiveDocument.Close xFileName = Dir() Wend Application.ScreenUpdating = TrueEnd Sub 来源：extendOffice]]></content>
      <tags>
        <tag>FileConvert</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随笔2019]]></title>
    <url>%2F2019%2F02%2F28%2F%E9%9A%8F%E7%AC%942019%2F</url>
    <content type="text"><![CDATA[2019年 日常记录 2019-2-28 初步设置好了个人博客 关于 Latex 数学公式在 Hexo 中使用的参考 即使使用了上述方法，行内公式只有使用行间公式的符号才正常显示，有悖于习惯与通用的 MarkDown 编辑器。并且转义仍存在 bug 2019-3-7 更改 npm 全局安装目录 npm config set cache &quot;C:\Environment\JavaScript\NodePackages&quot; npm config set prefix &quot;C:\Environment\JavaScript\NodePackages&quot; 修改 .\node_modules\npm 路径中的 npmrc 文件 prefix=C:\Environment\JavaScript\NodePackages cache=C:\Environment\JavaScript\NodePackages Tensorflow2.0 将要更新，接口会出现较大变动，最近 tensorflow 的程序跑起来时常看到 warning 逐渐习惯了使用 vscode 2019-3-9 不知道为什么，突然想到了很久之前看过的小说。幸运的是，很快就找到了。 中国百科全书（四） 巴别乱 2019-3-18 MDN web docs 2019-3-23 selenium chrome 无界面 123456from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')driver = webdriver.Chrome(options=chrome_options) tesserocr 安装 Python 输入，注意输出列表的第一个元组，例: (‘cp37’, ‘cp37m’, ‘win_amd64’) 12import pip._internalpip._internal.pep425tags.get_supported() tesserocr下载，从该网址下载与之前输出元组所对应的 .whl 文件 通过 pip 安装下载到本地的文件，例:pip3 install tesserocr-2.4.0-cp37-cp37m-win_amd64.whl，当前工作目录为文件所在的目录 2019-4-2 pyquery 长时间未维护，对于 CSS4 中的伪类选择器语法支持不足(当然，也可能是因为当前流行的仍然为 CSS3，毕竟对于 CSS4 的语法浏览器没有足够的动力去支持，只要 HTML 结构足够好的话，CSS3 对于伪类选择器的语法支持个人感觉已经足够)。例如:not(:has())就没有添加支持，使得选择不含有特定元素的所有元素变成一件很困难的事情(对一个结构比较糟糕的网站使用 HTML 解析时，这个功能可能很重要) 使用 BeautifulSoup 的选择器会是更好的选择，对于 CSS4 的语法支持较好 2019-4-4 python requests 编码问题 2019-6-1 JavaScript internal character encoding 2019-11-18 https://www.bilibili.com/video/av55210171?t=278 https://www.bilibili.com/video/av58023628?t=253 2019-11-19 CT 科学文库相关书目 计算机断层成像技术 : 原理、设计、伪像和进展CT图像重建算法工业CT技术与原理医学成像的物理原理]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐马尔可夫模型]]></title>
    <url>%2F2019%2F02%2F28%2FHMM%2F</url>
    <content type="text"><![CDATA[隐马尔可夫模型 (Hidden Markov Model) 是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其状态并不是直接可见的，但受状态影响的某些变量则是可见的，自然语言处理中被应用于中文分词。 缺点： 其做出的假设导致其不能考虑上下文的特征，限制了特征的选择 概念 马尔可夫模型：下一状态仅取决于当前状态，存在状态转移矩阵 隐马尔可夫模型：无法得知当前我想要的得知的状态（隐藏状态），但是可观察的状态与隐藏状态之间存在联系，根据可观察状态的序列找到一个最可能的隐藏状态序列 有限历史性假设 —— 下一状态仅取决于当前状态 齐次性假设 —— 状态转移概率与时刻无关 观察值独立性假设 —— 观察值仅取决于当前状态 五元组 观察序列（即文本）- O：小明硕士毕业于中国科学院计算所 状态序列 - S：BEBEBMEBEBMEBESB 代表该字是词语中的起始字​M 代表是词语中的中间字​E 代表是词语中的结束字​S 则代表是单字成词 初始状态概率向量－π：句子的第一个字属于{B,E,M,S}这四种状态的概率。 备注：示例数值是对概率值取对数之后的结果，为了将概率相乘的计算变成对数相加，其中-3.14e+100作为负无穷，也就是对应的概率值是 0​ 状态转移概率矩阵－A：已知前一个字的状态，后一个字状态为{B,E,M,S}的概率 观测概率矩阵－B：在在已知某一位置字的状态的条件下，观察值为特定字的概率 Viterbi 算法需要做的工作：找到的最大的 P(S_1, S_2, ... |\space O_1, O_2, ...)，并认为其对应的状态为每个文字实际的状态 P(S_1, S_2, ... |\space O_1, O_2, ...) = P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) / P(O_1, O_2, ...)因而只需要比较 P(O_1, O_2, ... |\space S_1, S_2, ...)* P(S_1, S_2, ...)齐次性假设: 状态转移矩阵不变观察值独立性假设: P(O_1, O_2, ... |\space S_1, S_2, ...) = P(O_1 |\space S_1, S_2, ...) * P(O_2 |\space S_1, S_2, ...) * ... = P(O_1 | S_1) * P(O_2 | S_2) * ...有限历史性假设: P(S_1, S_2, ...) = P(S_1) * P(S_2 | S_1) * P(S_3 | S_1, S_2) * ... = P(S_1) * P(S_2 | S_1) * P(S_3 | S_2) * ...P(O_1, O_2, ... |\space S_1, S_2, ...) * P(S_1, S_2, ...) = [P(O_1 | S_1) * P(S_1)] * [P(O_2 | S_2) * P(S_2 | S_1)] * [P(O_3 | S_3) * P(S_3 | S_2)] * ... 定义二维数组 weight[4][15]，4为状态的数量，15为输入句子的字数。 使用初始状态概率向量初始化 weight[i][0] 初始状态概率向量－π 已知 由观测概率矩阵得到 初始化 weight[i][0]，注: weight[i][0] = P(O1 | S1) * P(S1) 遍历句子计算 weight 二维数组weight[i][j] = max{ weight [t][j - 1] + transPos[t][i] + emitProb[i][sentence[j]], 其中 0&lt;= t &lt;= 3}transPos 为状态转移矩阵，emitPos 为观察概率矩阵 确定边界条件以及路径回溯 边界条件：句中最后一个字状态只可能为 E 或者 S 路径回溯：计算开始时可以新建一个与 weight 维数相同的矩阵，储存上一个字的状态，方便回溯 主要参考: 中文分词之HMM模型详解]]></content>
      <categories>
        <category>NLP</category>
        <category>中文分词</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello NexT]]></title>
    <url>%2F2019%2F02%2F27%2FHelloNexT%2F</url>
    <content type="text"><![CDATA[Theme NexT 安装当前目录为博客所在目录1git clone https://github.com/iissnan/hexo-theme-next themes/next NexTElegant Theme for Hexo]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
</search>
